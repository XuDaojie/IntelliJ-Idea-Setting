<application>
  <component name="AppStorage">
    <histories>
      <item value="&#9; * Instantiate and invoke all registered BeanPostProcessor beans,&#10;&#9; * respecting explicit order if given.&#10;&#9; * Must be called before singleton instantiation." />
      <item value="&#9; * Modify the application context's internal bean factory after its standard&#10;&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for overriding or adding&#10;&#9; * properties even to eager-initializing beans.&#10;&#9; * @param beanFactory the bean factory used by the application context" />
      <item value="&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for overriding or adding&#10;&#9; * properties even to eager-initializing beans.&#10;&#9; * @param beanFactory the bean factory used by the application context&#10;&#9; * @throws org.springframework.beans.BeansException in case of errors" />
      <item value="invoke factory processors registered with the context instance" />
      <item value="&#9; * Modify the application context's internal bean factory after its standard&#10;&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for registering special&#10;&#9; * BeanPostProcessors etc in certain ApplicationContext implementations.&#10;&#9; * @param beanFactory the bean factory used by the application context&#10;&#9; * @throws org.springframework.beans.BeansException in case of errors" />
      <item value="&#9; * Set the ResourceLoader that this object runs in.&#10;&#9; * &lt;p&gt;Invoked after population of normal bean properties but before an init&#10;&#9; * callback like InitializingBean's afterPropertiesSet or a custom init-method.&#10;&#9; * Invoked before ApplicationContextAware's setApplicationContext.&#10;&#9; * @param resourceLoader ResourceLoader object to be used by this object" />
      <item value="Aware" />
      <item value="&#9; * Subclasses must implement this method to perform the actual configuration load.&#10;&#9; * The method is invoked by refresh before any other initialization work.&#10;&#9; * @see #refresh" />
      <item value="&#9;&#9;// tell subclass to refresh the internal bean factory&#10;" />
      <item value="&#9; * Load or reload configuration.&#10;&#9; * @throws org.springframework.context.ApplicationContextException if the configuration&#10;&#9; * was invalid or couldn't be found, or if configuration has already been loaded and&#10;&#9; * reloading is forbidden&#10;&#9; * @throws BeansException if the bean factory could not be initialized" />
      <item value=" * &lt;p&gt;See PropertyResourceConfigurer and its concrete implementations&#10; * for out-of-the-box solutions that address such configuration needs." />
      <item value=" * &lt;p&gt;Useful for custom config files targeted at system administrators that&#10; * override bean properties configured in the application context." />
      <item value=" * Partial implementation of ApplicationContext. Doesn't mandate the type&#10; * of storage used for configuration, but implements common functionality.&#10; * Uses the Template Method design pattern, requiring concrete subclasses&#10; * to implement abstract methods.&#10; *&#10; * &lt;p&gt;In contrast to a plain bean factory, an ApplicationContext is supposed&#10; * to detect special beans defined in its bean factory: Therefore, this class&#10; * automatically registers BeanFactoryPostProcessors, BeanPostProcessors&#10; * and ApplicationListeners that are defined as beans in the context.&#10; *&#10; * &lt;p&gt;A MessageSource may be also supplied as a bean in the context, with&#10; * the name &quot;messageSource&quot;. Else, message resolution is delegated to the&#10; * parent context.&#10; *&#10; * &lt;p&gt;Implements resource loading through extending DefaultResourceLoader.&#10; * Therefore, treats resource paths as class path resources. Only supports&#10; * full classpath resource names that include the package path, like&#10; * &quot;mypackage/myresource.dat&quot;." />
      <item value="&#9; * Return a friendly name for this context.&#10;&#9; * @return a display name for this context" />
      <item value="&#9; * Return the timestamp when this context was first loaded.&#10;&#9; * @return the timestamp (ms) when this context was first loaded" />
      <item value="Listable" />
      <item value="Hierarchica" />
      <item value="Listable Bean Factory" />
      <item value="Hierarchical Bean Factory" />
      <item value=" * Central interface to provide configuration for an application.&#10; * This is read-only while the application is running, but may be&#10; * reloaded if the implementation supports this.&#10; *&#10; * &lt;p&gt;An ApplicationContext provides:&#10; * &lt;ul&gt;&#10; * &lt;li&gt;Bean factory methods, inherited from ListableBeanFactory.&#10; * This avoids the need for applications to use singletons.&#10; * &lt;li&gt;The ability to resolve messages, supporting internationalization.&#10; * Inherited from the MessageSource interface.&#10; * &lt;li&gt;The ability to load file resources in a generic fashion.&#10; * Inherited from the ResourceLoader interface.&#10; * &lt;li&gt;The ability to publish events. Implementations must provide a means&#10; * of registering event listeners.&#10; * &lt;li&gt;Inheritance from a parent context. Definitions in a descendant context&#10; * will always take priority. This means, for example, that a single parent&#10; * context can be used by an entire web application, while each servlet has&#10; * its own child context that is independent of that of any other servlet.&#10; * &lt;/ul&gt;&#10; *&#10; * &lt;p&gt;In addition to standard bean factory lifecycle capabilities,&#10; * ApplicationContext implementations need to detect ApplicationContextAware&#10; * beans and invoke the setApplicationContext method accordingly." />
      <item value=" * Central interface to provide configuration for an application.&#10; * This is read-only while the application is running, but may be&#10; * reloaded if the implementation supports this." />
      <item value="     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day&#10;     * number within the current year.  The first day of the year has value 1." />
      <item value="     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the&#10;     * day of the month. This is a synonym for &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.&#10;     * The first day of the month has value 1." />
      <item value=" * Allows for custom modification of new bean instances, e.g.&#10; * checking for marker interfaces or wrapping them with proxies.&#10; *&#10; * &lt;p&gt;Application contexts can auto-detect BeanPostProcessor beans in their&#10; * bean definitions and apply them before any other beans get created.&#10; * Plain bean factories allow for programmatic registration of post-processors.&#10; *&#10; * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces&#10; * or the like will implement postProcessBeforeInitialization, and post-processors&#10; * that wrap beans with proxies will normally implement postProcessAfterInitialization." />
      <item value="&#9;&#9;// We must check each PropertyValue to see whether it&#10;&#9;&#9;// requires a runtime reference to another bean to be resolved.&#10;&#9;&#9;// If it does, we'll attempt to instantiate the bean and set the reference." />
      <item value="&#9; * Given a PropertyValue, return a value, resolving any references to other&#10;&#9; * beans in the factory if necessary. The value could be:&#10;&#9; * &lt;li&gt;A BeanDefinition, which leads to the creation of a corresponding&#10;&#9; * new bean instance. Singleton flags and names of such &quot;inner beans&quot;&#10;&#9; * are always ignored: Inner beans are anonymous prototypes.&#10;&#9; * &lt;li&gt;A RuntimeBeanReference, which must be resolved.&#10;&#9; * &lt;li&gt;A ManagedList. This is a special collection that may contain&#10;&#9; * RuntimeBeanReferences or Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedSet. May also contain RuntimeBeanReferences or&#10;&#9; * Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedMap. In this case the value may be a RuntimeBeanReference&#10;&#9; * or Collection that will need to be resolved." />
      <item value="&#9;&#9;&#9;// synchronize if custom editors are registered&#10;&#9;&#9;&#9;// necessary because PropertyEditors are not thread-safe" />
      <item value="&#9;&#9;&#9;// update mutable copy&#10;" />
      <item value="&#9; * Deep copy constructor. Guarantees PropertyValue references&#10;&#9; * are independent, although it can't deep copy objects currently&#10;&#9; * referenced by individual PropertyValue objects" />
      <item value="Perform" />
      <item value="dependency" />
      <item value="&#9; * Perform a dependency check that all properties exposed have been set,&#10;&#9; * if desired. Dependency checks can be objects (collaborating beans)," />
      <item value="Populate the bean instance in the given BeanWrapper with the property values&#10;&#9; * from the bean definition." />
      <item value="populate" />
      <item value="The &quot;lib&quot; directory is just included in the &quot;-with-dependencies&quot; download. Make sure to download this full&#10;distribution ZIP file if you want to run the sample applications and/or build the framework yourself.&#10;Ant build scripts for the framework and the samples are provided. The standard samples can be built with&#10;the included Ant runtime by invoking the corresponding &quot;build.bat&quot; files (see samples subdirectories)." />
      <item value="&#9; * Initialize the given BeanWrapper with the custom editors registered&#10;&#9; * with this factory." />
      <item value="&#9; * Set the names of the beans that this bean depends on being initialized.&#10;&#9; * The bean factory will guarantee that these beans get initialized before.&#10;&#9; * &lt;p&gt;Note that dependencies are normally expressed through bean properties or&#10;&#9; * constructor arguments. This property should just be necessary for other kinds&#10;&#9; * of dependencies like statics (*ugh*) or database preparation on startup." />
      <item value="Return the bean names that this bean depends on." />
      <item value="re-check singleton cache within synchronized block" />
      <item value="Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition." />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;" />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;&#9; * Will ask the parent bean factory if not found in this instance." />
      <item value="check if bean definition exists" />
      <item value="&#9;&#9;// Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Register the given custom property editor for all properties of the&#10;&#9; * given type." />
      <item value=" * Default implementation of the BeanWrapper interface that should be sufficient&#10; * for all normal uses. Caches introspection results for efficiency.&#10; *&#10; * &lt;p&gt;Note: This class never tries to load a class by name, as this can pose&#10; * class loading problems in J2EE applications with multiple deployment modules.&#10; * The caller is responsible for loading a target class.&#10; *&#10; * &lt;p&gt;Note: Auto-registers all default property editors (not the custom ones)&#10; * in the org.springframework.beans.propertyeditors package.&#10; * Applications can either use a standard PropertyEditorManager to register a&#10; * custom editor before using a BeanWrapperImpl instance, or call the instance's&#10; * registerCustomEditor method to register an editor for the particular instance.&#10; *&#10; * &lt;p&gt;BeanWrapperImpl will convert List and array values to the corresponding&#10; * target arrays, if necessary. Custom property editors that deal with Lists or&#10; * arrays can be written against a comma delimited String as String arrays are&#10; * converted in such a format if the array itself is not assignable." />
      <item value="&#9; * Create new BeanWrapperImpl, wrapping a new instance of the specified class.&#10;" />
      <item value="Resolved A" />
      <item value="guarantee initialization of beans that the current one depends on" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="244" />
        <entry key="ENGLISH" value="245" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>