<application>
  <component name="AppStorage">
    <histories>
      <item value="         * When callerCl is null, we should check the application's&#10;         * (which is invoking this class indirectly)&#10;         * classloader, so that the JDBC driver class outside rt.jar&#10;         * can be loaded from here.&#10;         */" />
      <item value="     * Removes the specified driver from the {@code DriverManager}'s list of&#10;     * registered drivers.&#10;     * &lt;p&gt;&#10;     * If a {@code null} value is specified for the driver to be removed, then no&#10;     * action is taken.&#10;     * &lt;p&gt;&#10;     * If a security manager exists and its {@code checkPermission} denies&#10;     * permission, then a {@code SecurityException} will be thrown.&#10;     * &lt;p&gt;&#10;     * If the specified driver is not found in the list of registered drivers,&#10;     * then no action is taken.  If the driver was found, it will be removed&#10;     * from the list of registered drivers.&#10;     * &lt;p&gt;&#10;     * If a {@code DriverAction} instance was specified when the JDBC driver was&#10;     * registered, its deregister method will be called&#10;     * prior to the driver being removed from the list of registered drivers.&#10;     *&#10;     * @param driver the JDBC Driver to remove&#10;     * @exception SQLException if a database access error occurs&#10;     * @throws SecurityException if a security manager exists and its&#10;     * {@code checkPermission} method denies permission to deregister a driver.&#10;     *&#10;     * @see SecurityManager#checkPermission" />
      <item value="pure" />
      <item value="deadlock" />
      <item value=" * Interface for accessing attributes at runtime. This is a facade,&#10; * which can accommodate any attributes API such as Jakarta Commons Attributes,&#10; * or (possibly in future) a Spring attributes implementation.&#10; *&#10; * &lt;p&gt;The purpose of using this interface is to decouple Spring code from any&#10; * specific attributes implementation. Even once JSR-175 is available, there&#10; * is still value in such a facade interface, as it allows for hierarchical&#10; * attribute sources: for example, an XML file or properties file might override&#10; * some attributes defined in source-level metadata with JSR-175 or another framework." />
      <item value=" * A simple wrapper for exceptions that occur within the metadata package.&#10;" />
      <item value="reworked" />
      <item value="introduced" />
      <item value="unsatisfied" />
      <item value="&#9; * Return an array of object-type property names that are unsatisfied.&#10;&#9; * These are probably unsatisfied references to other beans in the&#10;&#9; * factory. Does not include simple properties like primitives or Strings." />
      <item value="&#9; * Fills in any missing property values with references to&#10;&#9; * other beans in this factory if autowire is set to &quot;byName&quot;." />
      <item value="Property Values" />
      <item value="Mutable" />
      <item value="&#9; * &quot;autowire constructor&quot; (with constructor arguments by type) behaviour.&#10;&#9; * Also applied if explicit constructor argument values are specified,&#10;&#9; * matching all remaining arguments with beans from the bean factory.&#10;&#9; * &lt;p&gt;This corresponds to constructor injection: In this mode, a Spring&#10;&#9; * bean factory is able to host components that expect constructor-based&#10;&#9; * dependency resolution." />
      <item value="Event raised when an ApplicationContext gets initialized or refreshed." />
      <item value=" * Interface to be implemented by event listeners.&#10; * Based on standard java.util base class for Observer" />
      <item value="&#9;&#9;// last step: publish respective event&#10;" />
      <item value="&#9;&#9;// instantiate singletons this late to allow them to access the message source&#10;" />
      <item value="&#9; * Add beans that implement ApplicationListener as listeners.&#10;&#9; * Doesn't affect other listeners, which can be added without being beans." />
      <item value=" * Utilities common to all UI application context implementations.&#10;" />
      <item value="Initialize the theme capability." />
      <item value="&#9; * Template method which can be overridden to add context-specific refresh work.&#10;&#9; * Called on initialization of special beans, before instantiation of singletons.&#10;&#9; * @throws BeansException in case of errors during refresh" />
      <item value="initialize other special beans in specific context subclasses" />
      <item value="&#9; * Instantiate and invoke all registered BeanPostProcessor beans,&#10;&#9; * respecting explicit order if given.&#10;&#9; * Must be called before singleton instantiation." />
      <item value="&#9; * Modify the application context's internal bean factory after its standard&#10;&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for overriding or adding&#10;&#9; * properties even to eager-initializing beans.&#10;&#9; * @param beanFactory the bean factory used by the application context" />
      <item value="&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for overriding or adding&#10;&#9; * properties even to eager-initializing beans.&#10;&#9; * @param beanFactory the bean factory used by the application context&#10;&#9; * @throws org.springframework.beans.BeansException in case of errors" />
      <item value="invoke factory processors registered with the context instance" />
      <item value="&#9; * Modify the application context's internal bean factory after its standard&#10;&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for registering special&#10;&#9; * BeanPostProcessors etc in certain ApplicationContext implementations.&#10;&#9; * @param beanFactory the bean factory used by the application context&#10;&#9; * @throws org.springframework.beans.BeansException in case of errors" />
      <item value="&#9; * Set the ResourceLoader that this object runs in.&#10;&#9; * &lt;p&gt;Invoked after population of normal bean properties but before an init&#10;&#9; * callback like InitializingBean's afterPropertiesSet or a custom init-method.&#10;&#9; * Invoked before ApplicationContextAware's setApplicationContext.&#10;&#9; * @param resourceLoader ResourceLoader object to be used by this object" />
      <item value="Aware" />
      <item value="&#9; * Subclasses must implement this method to perform the actual configuration load.&#10;&#9; * The method is invoked by refresh before any other initialization work.&#10;&#9; * @see #refresh" />
      <item value="&#9;&#9;// tell subclass to refresh the internal bean factory&#10;" />
      <item value="&#9; * Load or reload configuration.&#10;&#9; * @throws org.springframework.context.ApplicationContextException if the configuration&#10;&#9; * was invalid or couldn't be found, or if configuration has already been loaded and&#10;&#9; * reloading is forbidden&#10;&#9; * @throws BeansException if the bean factory could not be initialized" />
      <item value=" * &lt;p&gt;See PropertyResourceConfigurer and its concrete implementations&#10; * for out-of-the-box solutions that address such configuration needs." />
      <item value=" * &lt;p&gt;Useful for custom config files targeted at system administrators that&#10; * override bean properties configured in the application context." />
      <item value=" * Partial implementation of ApplicationContext. Doesn't mandate the type&#10; * of storage used for configuration, but implements common functionality.&#10; * Uses the Template Method design pattern, requiring concrete subclasses&#10; * to implement abstract methods.&#10; *&#10; * &lt;p&gt;In contrast to a plain bean factory, an ApplicationContext is supposed&#10; * to detect special beans defined in its bean factory: Therefore, this class&#10; * automatically registers BeanFactoryPostProcessors, BeanPostProcessors&#10; * and ApplicationListeners that are defined as beans in the context.&#10; *&#10; * &lt;p&gt;A MessageSource may be also supplied as a bean in the context, with&#10; * the name &quot;messageSource&quot;. Else, message resolution is delegated to the&#10; * parent context.&#10; *&#10; * &lt;p&gt;Implements resource loading through extending DefaultResourceLoader.&#10; * Therefore, treats resource paths as class path resources. Only supports&#10; * full classpath resource names that include the package path, like&#10; * &quot;mypackage/myresource.dat&quot;." />
      <item value="&#9; * Return a friendly name for this context.&#10;&#9; * @return a display name for this context" />
      <item value="&#9; * Return the timestamp when this context was first loaded.&#10;&#9; * @return the timestamp (ms) when this context was first loaded" />
      <item value="Listable" />
      <item value="Hierarchica" />
      <item value="Listable Bean Factory" />
      <item value="Hierarchical Bean Factory" />
      <item value=" * Central interface to provide configuration for an application.&#10; * This is read-only while the application is running, but may be&#10; * reloaded if the implementation supports this.&#10; *&#10; * &lt;p&gt;An ApplicationContext provides:&#10; * &lt;ul&gt;&#10; * &lt;li&gt;Bean factory methods, inherited from ListableBeanFactory.&#10; * This avoids the need for applications to use singletons.&#10; * &lt;li&gt;The ability to resolve messages, supporting internationalization.&#10; * Inherited from the MessageSource interface.&#10; * &lt;li&gt;The ability to load file resources in a generic fashion.&#10; * Inherited from the ResourceLoader interface.&#10; * &lt;li&gt;The ability to publish events. Implementations must provide a means&#10; * of registering event listeners.&#10; * &lt;li&gt;Inheritance from a parent context. Definitions in a descendant context&#10; * will always take priority. This means, for example, that a single parent&#10; * context can be used by an entire web application, while each servlet has&#10; * its own child context that is independent of that of any other servlet.&#10; * &lt;/ul&gt;&#10; *&#10; * &lt;p&gt;In addition to standard bean factory lifecycle capabilities,&#10; * ApplicationContext implementations need to detect ApplicationContextAware&#10; * beans and invoke the setApplicationContext method accordingly." />
      <item value=" * Central interface to provide configuration for an application.&#10; * This is read-only while the application is running, but may be&#10; * reloaded if the implementation supports this." />
      <item value="     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day&#10;     * number within the current year.  The first day of the year has value 1." />
      <item value="     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the&#10;     * day of the month. This is a synonym for &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.&#10;     * The first day of the month has value 1." />
      <item value=" * Allows for custom modification of new bean instances, e.g.&#10; * checking for marker interfaces or wrapping them with proxies.&#10; *&#10; * &lt;p&gt;Application contexts can auto-detect BeanPostProcessor beans in their&#10; * bean definitions and apply them before any other beans get created.&#10; * Plain bean factories allow for programmatic registration of post-processors.&#10; *&#10; * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces&#10; * or the like will implement postProcessBeforeInitialization, and post-processors&#10; * that wrap beans with proxies will normally implement postProcessAfterInitialization." />
      <item value="&#9;&#9;// We must check each PropertyValue to see whether it&#10;&#9;&#9;// requires a runtime reference to another bean to be resolved.&#10;&#9;&#9;// If it does, we'll attempt to instantiate the bean and set the reference." />
      <item value="&#9; * Given a PropertyValue, return a value, resolving any references to other&#10;&#9; * beans in the factory if necessary. The value could be:&#10;&#9; * &lt;li&gt;A BeanDefinition, which leads to the creation of a corresponding&#10;&#9; * new bean instance. Singleton flags and names of such &quot;inner beans&quot;&#10;&#9; * are always ignored: Inner beans are anonymous prototypes.&#10;&#9; * &lt;li&gt;A RuntimeBeanReference, which must be resolved.&#10;&#9; * &lt;li&gt;A ManagedList. This is a special collection that may contain&#10;&#9; * RuntimeBeanReferences or Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedSet. May also contain RuntimeBeanReferences or&#10;&#9; * Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedMap. In this case the value may be a RuntimeBeanReference&#10;&#9; * or Collection that will need to be resolved." />
      <item value="&#9;&#9;&#9;// synchronize if custom editors are registered&#10;&#9;&#9;&#9;// necessary because PropertyEditors are not thread-safe" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="270" />
        <entry key="ENGLISH" value="271" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="translateDocumentation" value="false" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>