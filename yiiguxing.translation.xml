<application>
  <component name="AppStorage">
    <histories>
      <item value="1. Those steps don't work currently for Intellij IDEA 13+&#10;2. `spring-aspects` does not compile out of the box due to references to aspect types unknown to IDEA.&#10;See http://youtrack.jetbrains.com/issue/IDEA-64446 for details. In the meantime, the 'spring-aspects'&#10;module has been excluded from the overall project to avoid compilation errors.&#10;3. While all JUnit tests pass from the command line with Gradle, many will fail when run from IDEA.&#10;Resolving this is a work in progress. If attempting to run all JUnit tests from within IDEA, you will&#10;likely need to set the following VM options to avoid out of memory errors:&#10;    -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m" />
      <item value=" Those steps don't work currently for Intellij IDEA 13+" />
      <item value="Waits for this future to be completed without interruption. This method catches an InterruptedException and discards it silently. " />
      <item value="Waits for this future to be completed without interruption. This method catches an InterruptedException and discards it silently.&#10;" />
      <item value="await Uninterruptibly" />
      <item value="     * Waits for this future to be completed without&#10;     * interruption.  This method catches an {@link InterruptedException} and&#10;     * discards it silently." />
      <item value="Expirable" />
      <item value="Acquires the lock with defined leaseTime. Waits if necessary until lock became available. Lock will be released automatically after defined leaseTime interval" />
      <item value=" java.util.concurrent.locks.Lock Acquires the lock only if it is free at the time of invocation. Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false. A typical usage idiom for this method would be:     Lock lock = ...;  if (lock.tryLock()) {    try {      // manipulate protected state    } finally {      lock.unlock();    }  } else {    // perform alternative actions  } This usage ensures that the lock is unlocked if it was acquired, and doesn't try to unlock if the lock was not acquired." />
      <item value="&#10;java.util.concurrent.locks.Lock Acquires the lock only if it is free at the time of invocation.&#10;Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false.&#10;A typical usage idiom for this method would be:&#10;  &#10; Lock lock = ...;&#10; if (lock.tryLock()) {&#10;   try {&#10;     // manipulate protected state&#10;   } finally {&#10;     lock.unlock();&#10;   }&#10; } else {&#10;   // perform alternative actions&#10; }&#10;This usage ensures that the lock is unlocked if it was acquired, and doesn't try to unlock if the lock was not acquired." />
      <item value="Acquires the lock. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired. Implementation Considerations A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation." />
      <item value="Acquires the lock.&#10;If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.&#10;Implementation Considerations&#10;A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation." />
      <item value="Acquires the lock only if it is free at the time of invocation. Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false. A typical usage idiom for this method would be:" />
      <item value="Acquires the lock only if it is free at the time of invocation.&#10;Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false.&#10;A typical usage idiom for this method would be:" />
      <item value="     * Waits for this future until it is done, and rethrows the cause of the failure if this future&#10;     * failed.&#10;     * &#10;     * @return Future object" />
      <item value="Waits for this future until it is done, and rethrows the cause of the failure if this future&#10;     * failed." />
      <item value=" * RedLock locking algorithm implementation for multiple locks. &#10; * It manages all locks as one." />
      <item value="remain" />
      <item value="interruptibly" />
      <item value="Base Redisson object" />
      <item value="acquired" />
      <item value="lease" />
      <item value="Remainin" />
      <item value="try Acquire" />
      <item value="acquire" />
      <item value="Marks this future as a success and notifies all&#10;     * listeners." />
      <item value=" * &lt;p&gt;All methods adhere to the above triggering, execution, and&#10; * exceptional completion specifications (which are not repeated in&#10; * individual method specifications). Additionally, while arguments&#10; * used to pass a completion result (that is, for parameters of type&#10; * {@code T}) for methods accepting them may be null, passing a null&#10; * value for any other parameter will result in a {@link&#10; * NullPointerException} being thrown.&#10; *&#10; * &lt;p&gt;This interface does not define methods for initially creating,&#10; * forcibly completing normally or exceptionally, probing completion&#10; * status or results, or awaiting completion of a stage.&#10; * Implementations of CompletionStage may provide means of achieving&#10; * such effects, as appropriate.  Method {@link #toCompletableFuture}&#10; * enables interoperability among different implementations of this&#10; * interface by providing a common conversion type." />
      <item value=" * Represents the result of an asynchronous computation&#10; * &#10; * @author Nikita Koksharov&#10; *&#10; * @param &lt;V&gt; type of value" />
      <item value="Acquired" />
      <item value="the maximum time to acquire the lock" />
      <item value="lease time" />
      <item value="     * Tries to acquire the lock with defined &lt;code&gt;leaseTime&lt;/code&gt;.&#10;     * Waits up to defined &lt;code&gt;waitTime&lt;/code&gt; if necessary until the lock became available.&#10;     *&#10;     * Lock will be released automatically after defined &lt;code&gt;leaseTime&lt;/code&gt; interval." />
      <item value="lease Time" />
      <item value="Interruptibly" />
      <item value="    /**      * Atomically adds the given value to the current value of a field      * or array element within the given object {@code o}      * at the given {@code offset}.      *      * @param o object/array to update the field/element in      * @param offset field/element offset      * @param delta the value to add      * @return the previous value      * @since 1.8      */" />
      <item value="    /**&#10;     * Atomically adds the given value to the current value of a field&#10;     * or array element within the given object {@code o}&#10;     * at the given {@code offset}.&#10;     *&#10;     * @param o object/array to update the field/element in&#10;     * @param offset field/element offset&#10;     * @param delta the value to add&#10;     * @return the previous value&#10;     * @since 1.8&#10;     */" />
      <item value="     * Atomically updates Java variable to {@code x} if it is currently&#10;     * holding {@code expected}.&#10;     *&#10;     * &lt;p&gt;This operation has memory semantics of a {@code volatile} read&#10;     * and write.  Corresponds to C11 atomic_compare_exchange_strong.&#10;     *&#10;     * @return {@code true} if successful" />
      <item value="    /// peek and poke operations&#10;    /// (compilers should optimize these to memory ops)&#10;&#10;    // These work on object fields in the Java heap.&#10;    // They will not work on elements of packed arrays." />
      <item value=" * A collection of methods for performing low-level, unsafe operations.&#10; * Although the class and all methods are public, use of this class is&#10; * limited because only trusted code can obtain instances of it.&#10; *&#10; * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure&#10; * arguments are checked before methods of this class are&#10; * called. While some rudimentary checks are performed on the input,&#10; * the checks are best effort and when performance is an overriding&#10; * priority, as when methods of this class are optimized by the&#10; * runtime compiler, some or all checks (if any) may be elided. Hence,&#10; * the caller must not rely on the checks and corresponding&#10; * exceptions!" />
      <item value="* A collection of methods for performing low-level, unsafe operations. * Although the class and all methods are public, use of this class is * limited because only trusted code can obtain instances of it. * * &lt;em&gt;Note:&lt;/em&gt; It is the resposibility of the caller to make sure * arguments are checked before methods of this class are * called. While some rudimentary checks are performed on the input, * the checks are best effort and when performance is an overriding * priority, as when methods of this class are optimized by the * runtime compiler, some or all checks (if any) may be elided. Hence, * the caller must not rely on the checks and corresponding * exceptions!" />
      <item value="* Causes the currently executing thread to sleep (temporarily cease * execution) for the specified number of milliseconds, subject to * the precision and accuracy of system timers and schedulers. The thread * does not lose ownership of any monitors." />
      <item value="* if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown." />
      <item value="* InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class." />
      <item value="* Defines the part common to all monitor MBeans. * A monitor MBean monitors values of an attribute common to a set of observed * MBeans. The observed attribute is monitored at intervals specified by the * granularity period. A gauge value (derived gauge) is derived from the values * of the observed attribute." />
      <item value="Helps transfer if a resize is in progress." />
      <item value="* Maps the specified key to the specified value in this table. * Neither the key nor the value can be null. * * &lt;p&gt;The value can be retrieved by calling the {@code get} method * with a key that is equal to the original key. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with {@code key}, or * {@code null} if there was no mapping for {@code key} * @throws NullPointerException if the specified key or value is null" />
      <item value="Stripped-down version of helper class used in previous version, * declared for the sake of serialization compatibility" />
      <item value="* Stripped-down version of helper class used in previous version, * declared for the sake of serialization compatibility" />
      <item value="* &lt;strong&gt;NOTE: This class is obsolete. New implementations should * implement the Map interface, rather than extending this class.&lt;/strong&gt;" />
      <item value="* The &lt;code&gt;Dictionary&lt;/code&gt; class is the abstract parent of any * class, such as &lt;code&gt;Hashtable&lt;/code&gt;, which maps keys to values. * Every key and every value is an object. In any one &lt;tt&gt;Dictionary&lt;/tt&gt; * object, every key is associated with at most one value. Given a * &lt;tt&gt;Dictionary&lt;/tt&gt; and a key, the associated element can be looked up. * Any non-&lt;code&gt;null&lt;/code&gt; object can be used as a key and as a value. * &lt;p&gt; * As a rule, the &lt;code&gt;equals&lt;/code&gt; method should be used by * implementations of this class to decide if two keys are the same. * &lt;p&gt; * &lt;strong&gt;NOTE: This class is obsolete. New implementations should * implement the Map interface, rather than extending this class.&lt;/strong&gt;" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="161" />
        <entry key="ENGLISH" value="162" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>