<application>
  <component name="AppStorage">
    <histories>
      <item value=" * Allows for custom modification of new bean instances, e.g.&#10; * checking for marker interfaces or wrapping them with proxies.&#10; *&#10; * &lt;p&gt;Application contexts can auto-detect BeanPostProcessor beans in their&#10; * bean definitions and apply them before any other beans get created.&#10; * Plain bean factories allow for programmatic registration of post-processors.&#10; *&#10; * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces&#10; * or the like will implement postProcessBeforeInitialization, and post-processors&#10; * that wrap beans with proxies will normally implement postProcessAfterInitialization." />
      <item value="&#9;&#9;// We must check each PropertyValue to see whether it&#10;&#9;&#9;// requires a runtime reference to another bean to be resolved.&#10;&#9;&#9;// If it does, we'll attempt to instantiate the bean and set the reference." />
      <item value="&#9; * Given a PropertyValue, return a value, resolving any references to other&#10;&#9; * beans in the factory if necessary. The value could be:&#10;&#9; * &lt;li&gt;A BeanDefinition, which leads to the creation of a corresponding&#10;&#9; * new bean instance. Singleton flags and names of such &quot;inner beans&quot;&#10;&#9; * are always ignored: Inner beans are anonymous prototypes.&#10;&#9; * &lt;li&gt;A RuntimeBeanReference, which must be resolved.&#10;&#9; * &lt;li&gt;A ManagedList. This is a special collection that may contain&#10;&#9; * RuntimeBeanReferences or Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedSet. May also contain RuntimeBeanReferences or&#10;&#9; * Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedMap. In this case the value may be a RuntimeBeanReference&#10;&#9; * or Collection that will need to be resolved." />
      <item value="&#9;&#9;&#9;// synchronize if custom editors are registered&#10;&#9;&#9;&#9;// necessary because PropertyEditors are not thread-safe" />
      <item value="&#9;&#9;&#9;// update mutable copy&#10;" />
      <item value="&#9; * Deep copy constructor. Guarantees PropertyValue references&#10;&#9; * are independent, although it can't deep copy objects currently&#10;&#9; * referenced by individual PropertyValue objects" />
      <item value="Perform" />
      <item value="dependency" />
      <item value="&#9; * Perform a dependency check that all properties exposed have been set,&#10;&#9; * if desired. Dependency checks can be objects (collaborating beans)," />
      <item value="Populate the bean instance in the given BeanWrapper with the property values&#10;&#9; * from the bean definition." />
      <item value="populate" />
      <item value="The &quot;lib&quot; directory is just included in the &quot;-with-dependencies&quot; download. Make sure to download this full&#10;distribution ZIP file if you want to run the sample applications and/or build the framework yourself.&#10;Ant build scripts for the framework and the samples are provided. The standard samples can be built with&#10;the included Ant runtime by invoking the corresponding &quot;build.bat&quot; files (see samples subdirectories)." />
      <item value="&#9; * Initialize the given BeanWrapper with the custom editors registered&#10;&#9; * with this factory." />
      <item value="&#9; * Set the names of the beans that this bean depends on being initialized.&#10;&#9; * The bean factory will guarantee that these beans get initialized before.&#10;&#9; * &lt;p&gt;Note that dependencies are normally expressed through bean properties or&#10;&#9; * constructor arguments. This property should just be necessary for other kinds&#10;&#9; * of dependencies like statics (*ugh*) or database preparation on startup." />
      <item value="Return the bean names that this bean depends on." />
      <item value="re-check singleton cache within synchronized block" />
      <item value="Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition." />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;" />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;&#9; * Will ask the parent bean factory if not found in this instance." />
      <item value="check if bean definition exists" />
      <item value="&#9;&#9;// Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Register the given custom property editor for all properties of the&#10;&#9; * given type." />
      <item value=" * Default implementation of the BeanWrapper interface that should be sufficient&#10; * for all normal uses. Caches introspection results for efficiency.&#10; *&#10; * &lt;p&gt;Note: This class never tries to load a class by name, as this can pose&#10; * class loading problems in J2EE applications with multiple deployment modules.&#10; * The caller is responsible for loading a target class.&#10; *&#10; * &lt;p&gt;Note: Auto-registers all default property editors (not the custom ones)&#10; * in the org.springframework.beans.propertyeditors package.&#10; * Applications can either use a standard PropertyEditorManager to register a&#10; * custom editor before using a BeanWrapperImpl instance, or call the instance's&#10; * registerCustomEditor method to register an editor for the particular instance.&#10; *&#10; * &lt;p&gt;BeanWrapperImpl will convert List and array values to the corresponding&#10; * target arrays, if necessary. Custom property editors that deal with Lists or&#10; * arrays can be written against a comma delimited String as String arrays are&#10; * converted in such a format if the array itself is not assignable." />
      <item value="&#9; * Create new BeanWrapperImpl, wrapping a new instance of the specified class.&#10;" />
      <item value="Resolved A" />
      <item value="guarantee initialization of beans that the current one depends on" />
      <item value="&#9; * Create a bean instance for the given bean definition.&#10;&#9; * The bean definition will already have been merged with the parent&#10;&#9; * definition in case of a child definition.&#10;&#9; * &lt;p&gt;All the other methods in this class invoke this method, although&#10;&#9; * beans may be cached after being instantiated by this method. All bean&#10;&#9; * instantiation within this class is performed by this method." />
      <item value="&#9; * Get the object for the given shared bean, either the bean&#10;&#9; * instance itself or its created object in case of a FactoryBean." />
      <item value="eagerly check singleton cache for manually registered singletons" />
      <item value="&#9; * Return the bean name, stripping out the factory dereference prefix if necessary,&#10;&#9; * and resolving aliases to canonical names." />
      <item value="Return the set of classes that will get ignored for autowiring." />
      <item value=" * Abstract superclass for BeanFactory implementations.&#10; * Implements the ConfigurableBeanFactory SPI interface.&#10; *&#10; * &lt;p&gt;This class provides singleton/prototype determination, singleton cache,&#10; * aliases, FactoryBean handling, and bean definition merging for child bean&#10; * definitions. It also allows for management of a bean factory hierarchy,&#10; * implementing the HierarchicalBeanFactory interface.&#10; *&#10; * &lt;p&gt;The main template methods to be implemented by subclasses are&#10; * getBeanDefinition and createBean, retrieving a bean definition for&#10; * a given bean name respectively creating a bean instance for a given&#10; * bean definition." />
      <item value="Parent bean factory, for bean inheritance support" />
      <item value="&#9; * Create a new AbstractBeanFactory with the given parent." />
      <item value="&#9; * Parse an element definition: We know this is a BEAN element.&#10;&#9; * Bean elements specify their canonical name as id attribute&#10;&#9; * and their aliases as a delimited name attribute.&#10;&#9; * If no id specified, use the first name in the name attribute as&#10;&#9; * canonical name, registering all others as aliases." />
      <item value=" * Abstract base class for bean definition readers.&#10; * Provides common properties like the bean factory to work on&#10; * and the class loader to use for loading bean classes. " />
      <item value=" * Bean definition reader for Spring's default XML bean definition format.&#10; * Typically applied to a DefaultListableBeanFactory.&#10; *&#10; * &lt;p&gt;The structure, element and attribute names of the required XML document&#10; * are hard-coded in this class. (Of course a transform could be run if necessary&#10; * to produce this format). &quot;beans&quot; doesn't need to be the root element of the XML&#10; * document: This class will parse all bean definition elements in the XML file.&#10; *&#10; * &lt;p&gt;This class registers each bean definition with the given bean factory superclass,&#10; * and relies on the latter's implementation of the BeanDefinitionRegistry interface.&#10; * It supports singletons, prototypes, and references to either of these kinds of bean." />
      <item value="&#9; * Register the bean definitions contained in the given DOM document.&#10;&#9; * All calls go through this." />
      <item value="&#9; * Load bean definitions from the specified XML file.&#10;" />
      <item value="&#9; * Set a SAX entity resolver to be used for parsing. By default, BeansDtdResolver&#10;&#9; * will be used. Can be overridden for custom entity resolution, e.g. relative&#10;&#9; * to some specific base path." />
      <item value="Resolver" />
      <item value=" * Default implementation of the XmlBeanDefinitionParser interface.&#10; * Parses bean definitions according to the &quot;spring-beans&quot; DTD. " />
      <item value="&#9; * Register the bean definitions contained in the given DOM document.&#10;&#9; * All calls go through this.&#10;&#9; * @param doc the DOM document&#10;&#9; * @throws BeansException in case of parsing errors" />
      <item value=" * Strategy interface for parsing XML bean definitions.&#10; * Used by XmlBeanDefinitionReader for actually parsing a DOM document.&#10; *&#10; * &lt;p&gt;Instantiated per document to parse: Implementations can hold state in&#10; * instance variables during the execution of the registerBeanDefinitions&#10; * method, for example global settings that are defined for all bean&#10; * definitions in the document." />
      <item value="&#9; * Parse bean definitions from the given DOM document,&#10;&#9; * and register them with the given bean factory.&#10;&#9; * @param beanFactory the bean factory to register the bean definitions with&#10;&#9; * @param beanClassLoader class loader to use for bean classes&#10;&#9; * (null suggests to not load bean classes but just register bean definitions&#10;&#9; * with class names, for example when just registering beans in a registry&#10;&#9; * but not actually instantiating them in a factory)&#10;&#9; * @param doc the DOM document&#10;&#9; * @param resource descriptor of the original XML resource&#10;&#9; * (useful for displaying parse errors)&#10;&#9; * @throws BeansException in case of parsing errors" />
      <item value=" * Abstract BeanFactory superclass that implements default bean creation.&#10; * Implements the AutowireCapableBeanFactory interface.&#10; *&#10; * &lt;p&gt;Provides bean creation, initialization and wiring, supporting&#10; * autowiring and constructor resolution. Handles runtime bean references,&#10; * managed collections, and bean destruction.&#10; *&#10; * &lt;p&gt;The main template method to be implemented by subclasses is&#10; * findMatchingBeans, used for autowiring by type. Note that this class&#10; * does &lt;i&gt;not&lt;/i&gt; implement bean definition registry capabilities&#10; * (DefaultListableBeanFactory does)." />
      <item value="definitions" />
      <item value="1. Those steps don't work currently for Intellij IDEA 13+&#10;2. `spring-aspects` does not compile out of the box due to references to aspect types unknown to IDEA.&#10;See http://youtrack.jetbrains.com/issue/IDEA-64446 for details. In the meantime, the 'spring-aspects'&#10;module has been excluded from the overall project to avoid compilation errors.&#10;3. While all JUnit tests pass from the command line with Gradle, many will fail when run from IDEA.&#10;Resolving this is a work in progress. If attempting to run all JUnit tests from within IDEA, you will&#10;likely need to set the following VM options to avoid out of memory errors:&#10;    -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m" />
      <item value=" Those steps don't work currently for Intellij IDEA 13+" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="220" />
        <entry key="ENGLISH" value="221" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="SPANISH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>