<application>
  <component name="AppStorage">
    <histories>
      <item value="If manual, trigger search by pressing enter key or search button." />
      <item value="Preload the search data when the page loads." />
      <item value="Unescape html strings to the readable one." />
      <item value="better Performance" />
      <item value="Show number of visitors to each article." />
      <item value="Remove unnecessary files after hexo generate." />
      <item value="Enable sidebar on narrow view" />
      <item value="Specify the date when the site was setup. If not defined, current year will be used." />
      <item value="transition" />
      <item value="# If false, merge configs from `_data/next.yml` into default configuration (rewrite).&#10;# If true, will fully override default configuration by options from `_data/next.yml` (override). Only for NexT settings.&#10;# And if true, all config from default NexT `_config.yml` must be copied into `next.yml`. Use if you know what you are doing.&#10;# Useful if you want to comment some options from NexT `_config.yml` by `next.yml` without editing default config." />
      <item value="* Build message codes for the given error code and object name. * Used for building the codes list of an ObjectError. * @param errorCode the error code used for rejecting the object * @param objectName the name of the object * @return the message codes to use" />
      <item value="fluent" />
      <item value="Fluent" />
      <item value="h the invocation handler to dispatch method invocations to" />
      <item value="the list of interfaces for the proxy class * to implement" />
      <item value="the class loader to define the proxy class" />
      <item value="Spring's repackaging of * &lt;a href=&quot;https://github.com/cglib/cglib&quot;&gt;CGLIB 3.3&lt;/a&gt; * (with Spring-specific patches; for internal use only). * * &lt;p&gt;This repackaging technique avoids any potential conflicts with * dependencies on CGLIB at the application level or from third-party * libraries and frameworks. * * &lt;p&gt;As this repackaging happens at the class file level, sources * and javadocs are not available here." />
      <item value="* A visitor to visit a Java annotation. The methods of this class must be called in the following * order: ( {@code visit} | {@code visitEnum} | {@code visitAnnotation} | {@code visitArray} )* * {@code visitEnd}. * * @author Eric Bruneton * @author Eugene Kuleshov" />
      <item value="Empty class used to ensure that the {@code org.springframework.cglib} * package is processed during javadoc generation. * * &lt;p&gt;See &lt;a href=&quot;package-summary.html&quot;&gt;package-level javadocs&lt;/a&gt; for more * information on {@code org.springframework.cglib}. * * @author Chris Beams * @since 3.2" />
      <item value="depend on org.springframework.asm; this avoids including two different copies of asm." />
      <item value="cglib itself depends on asm and is therefore further transformed by the JarJar task to" />
      <item value="spring-core includes asm and repackages cglib, inlining both into the spring-core jar." />
      <item value="pantsbuild" />
      <item value="As mentioned above, transform cglib's internal asm dependencies from // org.objectweb.asm =&gt; org.springframework.asm. Doing this counts on the // the fact that Spring and cglib depend on the same version of asm!" />
      <item value="When prompted exclude the spring-aspects module (or after the import via File-&gt; Project Structure -&gt; Modules)" />
      <item value="// log4j-to-slf4j bridge -&gt; we'll rather go with the SLF4J SPI; // however, we still prefer Log4j over the plain SLF4J API since // the latter does not have location awareness support." />
      <item value="Present" />
      <item value="* Spring's variant of the * &lt;a href=&quot;https://commons.apache.org/logging&quot;&gt;Commons Logging API&lt;/a&gt;: * with special support for Log4J 2, SLF4J and {@code java.util.logging}. * * &lt;p&gt;This is a custom bridge along the lines of {@code jcl-over-slf4j}. * You may exclude {@code spring-jcl} and switch to {@code jcl-over-slf4j} * instead if you prefer the hard-bound SLF4J bridge. However, Spring's own * bridge provides a better out-of-the-box experience when using Log4J 2 * or {@code java.util.logging}, with no extra bridge jars necessary, and * also easier setup of SLF4J with Logback (no JCL exclude, no JCL bridge). * * &lt;p&gt;{@link org.apache.commons.logging.Log} is equivalent to the original. * However, {@link org.apache.commons.logging.LogFactory} is a very different * implementation which is minimized and optimized for Spring's purposes, * detecting Log4J 2.x and SLF4J 1.7 in the framework classpath and falling * back to {@code java.util.logging}. If you run into any issues with this * implementation, consider excluding {@code spring-jcl} and switching to the * standard {@code commons-logging} artifact or to {@code jcl-over-slf4j}. * * &lt;p&gt;Note that this Commons Logging bridge is only meant to be used for * framework logging purposes, both in the core framework and in extensions. * For applications, prefer direct use of Log4J/SLF4J or {@code java.util.logging}." />
      <item value="Low level support for Cloud deployments." />
      <item value="lower bound" />
      <item value="pageTotal" />
      <item value="pagetotal" />
      <item value="total" />
      <item value="hikari" />
      <item value="Mark one as primary or declare a specific CacheManager to use." />
      <item value="specified" />
      <item value="declare" />
      <item value="primary" />
      <item value="determin" />
      <item value="Parse" />
      <item value="Detect any custom bean name generation strategy supplied through the enclosing application context" />
      <item value="Sort by previously determined @Order value, if applicable" />
      <item value="Parses" />
      <item value="* The auto-configure classes that should have not yet been applied." />
      <item value="* Hint for that an {@link EnableAutoConfiguration auto-configuration} should be applied * after other specified auto-configuration classes." />
      <item value="* Auto-configuration classes are regular Spring {@link Configuration} beans. They are * located using the {@link SpringFactoriesLoader} mechanism (keyed against this class). * Generally auto-configuration beans are {@link Conditional @Conditional} beans (most * often using {@link ConditionalOnClass @ConditionalOnClass} and * {@link ConditionalOnMissingBean @ConditionalOnMissingBean} annotations)." />
      <item value="* Enable auto-configuration of the Spring Application Context, attempting to guess and * configure beans that you are likely to need. Auto-configuration classes are usually * applied based on your classpath and what beans you have defined. For example, if you * have {@code tomcat-embedded.jar} on your classpath you are likely to want a * {@link TomcatServletWebServerFactory} (unless you have defined your own * {@link ServletWebServerFactory} bean). * &lt;p&gt; * When using {@link SpringBootApplication}, the auto-configuration of the context is * automatically enabled and adding this annotation has therefore no additional effect. * &lt;p&gt; * Auto-configuration tries to be as intelligent as possible and will back-away as you * define more of your own configuration. You can always manually {@link #exclude()} any * configuration that you never want to apply (use {@link #excludeName()} if you don't * have access to them). You can also exclude them via the * {@code spring.autoconfigure.exclude} property. Auto-configuration is always applied * after user-defined beans have been registered. * &lt;p&gt; * The package of the class that is annotated with {@code @EnableAutoConfiguration}, * usually via {@code @SpringBootApplication}, has specific significance and is often used * as a 'default'. For example, it will be used when scanning for {@code @Entity} classes. * It is generally recommended that you place {@code @EnableAutoConfiguration} (if you're * not using {@code @SpringBootApplication}) in a root package so that all sub-packages * and classes can be searched. * &lt;p&gt; * Auto-configuration classes are regular Spring {@link Configuration} beans. They are * located using the {@link SpringFactoriesLoader} mechanism (keyed against this class). * Generally auto-configuration beans are {@link Conditional @Conditional} beans (most * often using {@link ConditionalOnClass @ConditionalOnClass} and * {@link ConditionalOnMissingBean @ConditionalOnMissingBean} annotations)." />
      <item value="unkown" />
      <item value="* Annotation for interfaces declaring that a REST client with that interface should be * created (e.g. for autowiring into another component). If ribbon is available it will be * used to load balance the backend requests, and the load balancer can be configured * using a &lt;code&gt;@RibbonClient&lt;/code&gt; with the same name (i.e. value) as the feign client." />
      <item value="A builder for creating Feign clients without using the {@link FeignClient} annotation. * &lt;p&gt; * This builder builds the Feign client exactly like it would be created by using the * {@link FeignClient} annotation." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="68" />
        <entry key="ENGLISH" value="69" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
        <option name="appKeyConfigured" value="true" />
      </youdao-translate>
    </option>
  </component>
</application>