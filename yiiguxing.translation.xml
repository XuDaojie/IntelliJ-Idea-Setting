<application>
  <component name="AppStorage">
    <histories>
      <item value=" * Partial implementation of ApplicationContext. Doesn't mandate the type&#10; * of storage used for configuration, but implements common functionality.&#10; * Uses the Template Method design pattern, requiring concrete subclasses&#10; * to implement abstract methods.&#10; *&#10; * &lt;p&gt;In contrast to a plain bean factory, an ApplicationContext is supposed&#10; * to detect special beans defined in its bean factory: Therefore, this class&#10; * automatically registers BeanFactoryPostProcessors, BeanPostProcessors&#10; * and ApplicationListeners that are defined as beans in the context.&#10; *&#10; * &lt;p&gt;A MessageSource may be also supplied as a bean in the context, with&#10; * the name &quot;messageSource&quot;. Else, message resolution is delegated to the&#10; * parent context.&#10; *&#10; * &lt;p&gt;Implements resource loading through extending DefaultResourceLoader.&#10; * Therefore, treats resource paths as class path resources. Only supports&#10; * full classpath resource names that include the package path, like&#10; * &quot;mypackage/myresource.dat&quot;." />
      <item value="&#9; * Return a friendly name for this context.&#10;&#9; * @return a display name for this context" />
      <item value="&#9; * Return the timestamp when this context was first loaded.&#10;&#9; * @return the timestamp (ms) when this context was first loaded" />
      <item value="Aware" />
      <item value="Listable" />
      <item value="Hierarchica" />
      <item value="Listable Bean Factory" />
      <item value="Hierarchical Bean Factory" />
      <item value=" * Central interface to provide configuration for an application.&#10; * This is read-only while the application is running, but may be&#10; * reloaded if the implementation supports this.&#10; *&#10; * &lt;p&gt;An ApplicationContext provides:&#10; * &lt;ul&gt;&#10; * &lt;li&gt;Bean factory methods, inherited from ListableBeanFactory.&#10; * This avoids the need for applications to use singletons.&#10; * &lt;li&gt;The ability to resolve messages, supporting internationalization.&#10; * Inherited from the MessageSource interface.&#10; * &lt;li&gt;The ability to load file resources in a generic fashion.&#10; * Inherited from the ResourceLoader interface.&#10; * &lt;li&gt;The ability to publish events. Implementations must provide a means&#10; * of registering event listeners.&#10; * &lt;li&gt;Inheritance from a parent context. Definitions in a descendant context&#10; * will always take priority. This means, for example, that a single parent&#10; * context can be used by an entire web application, while each servlet has&#10; * its own child context that is independent of that of any other servlet.&#10; * &lt;/ul&gt;&#10; *&#10; * &lt;p&gt;In addition to standard bean factory lifecycle capabilities,&#10; * ApplicationContext implementations need to detect ApplicationContextAware&#10; * beans and invoke the setApplicationContext method accordingly." />
      <item value=" * Central interface to provide configuration for an application.&#10; * This is read-only while the application is running, but may be&#10; * reloaded if the implementation supports this." />
      <item value="     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the day&#10;     * number within the current year.  The first day of the year has value 1." />
      <item value="     * Field number for &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; indicating the&#10;     * day of the month. This is a synonym for &lt;code&gt;DAY_OF_MONTH&lt;/code&gt;.&#10;     * The first day of the month has value 1." />
      <item value=" * Allows for custom modification of new bean instances, e.g.&#10; * checking for marker interfaces or wrapping them with proxies.&#10; *&#10; * &lt;p&gt;Application contexts can auto-detect BeanPostProcessor beans in their&#10; * bean definitions and apply them before any other beans get created.&#10; * Plain bean factories allow for programmatic registration of post-processors.&#10; *&#10; * &lt;p&gt;Typically, post-processors that populate beans via marker interfaces&#10; * or the like will implement postProcessBeforeInitialization, and post-processors&#10; * that wrap beans with proxies will normally implement postProcessAfterInitialization." />
      <item value="&#9;&#9;// We must check each PropertyValue to see whether it&#10;&#9;&#9;// requires a runtime reference to another bean to be resolved.&#10;&#9;&#9;// If it does, we'll attempt to instantiate the bean and set the reference." />
      <item value="&#9; * Given a PropertyValue, return a value, resolving any references to other&#10;&#9; * beans in the factory if necessary. The value could be:&#10;&#9; * &lt;li&gt;A BeanDefinition, which leads to the creation of a corresponding&#10;&#9; * new bean instance. Singleton flags and names of such &quot;inner beans&quot;&#10;&#9; * are always ignored: Inner beans are anonymous prototypes.&#10;&#9; * &lt;li&gt;A RuntimeBeanReference, which must be resolved.&#10;&#9; * &lt;li&gt;A ManagedList. This is a special collection that may contain&#10;&#9; * RuntimeBeanReferences or Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedSet. May also contain RuntimeBeanReferences or&#10;&#9; * Collections that will need to be resolved.&#10;&#9; * &lt;li&gt;A ManagedMap. In this case the value may be a RuntimeBeanReference&#10;&#9; * or Collection that will need to be resolved." />
      <item value="&#9;&#9;&#9;// synchronize if custom editors are registered&#10;&#9;&#9;&#9;// necessary because PropertyEditors are not thread-safe" />
      <item value="&#9;&#9;&#9;// update mutable copy&#10;" />
      <item value="&#9; * Deep copy constructor. Guarantees PropertyValue references&#10;&#9; * are independent, although it can't deep copy objects currently&#10;&#9; * referenced by individual PropertyValue objects" />
      <item value="Perform" />
      <item value="dependency" />
      <item value="&#9; * Perform a dependency check that all properties exposed have been set,&#10;&#9; * if desired. Dependency checks can be objects (collaborating beans)," />
      <item value="Populate the bean instance in the given BeanWrapper with the property values&#10;&#9; * from the bean definition." />
      <item value="populate" />
      <item value="The &quot;lib&quot; directory is just included in the &quot;-with-dependencies&quot; download. Make sure to download this full&#10;distribution ZIP file if you want to run the sample applications and/or build the framework yourself.&#10;Ant build scripts for the framework and the samples are provided. The standard samples can be built with&#10;the included Ant runtime by invoking the corresponding &quot;build.bat&quot; files (see samples subdirectories)." />
      <item value="&#9; * Initialize the given BeanWrapper with the custom editors registered&#10;&#9; * with this factory." />
      <item value="&#9; * Set the names of the beans that this bean depends on being initialized.&#10;&#9; * The bean factory will guarantee that these beans get initialized before.&#10;&#9; * &lt;p&gt;Note that dependencies are normally expressed through bean properties or&#10;&#9; * constructor arguments. This property should just be necessary for other kinds&#10;&#9; * of dependencies like statics (*ugh*) or database preparation on startup." />
      <item value="Return the bean names that this bean depends on." />
      <item value="re-check singleton cache within synchronized block" />
      <item value="Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition." />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;" />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;&#9; * Will ask the parent bean factory if not found in this instance." />
      <item value="check if bean definition exists" />
      <item value="&#9;&#9;// Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Register the given custom property editor for all properties of the&#10;&#9; * given type." />
      <item value=" * Default implementation of the BeanWrapper interface that should be sufficient&#10; * for all normal uses. Caches introspection results for efficiency.&#10; *&#10; * &lt;p&gt;Note: This class never tries to load a class by name, as this can pose&#10; * class loading problems in J2EE applications with multiple deployment modules.&#10; * The caller is responsible for loading a target class.&#10; *&#10; * &lt;p&gt;Note: Auto-registers all default property editors (not the custom ones)&#10; * in the org.springframework.beans.propertyeditors package.&#10; * Applications can either use a standard PropertyEditorManager to register a&#10; * custom editor before using a BeanWrapperImpl instance, or call the instance's&#10; * registerCustomEditor method to register an editor for the particular instance.&#10; *&#10; * &lt;p&gt;BeanWrapperImpl will convert List and array values to the corresponding&#10; * target arrays, if necessary. Custom property editors that deal with Lists or&#10; * arrays can be written against a comma delimited String as String arrays are&#10; * converted in such a format if the array itself is not assignable." />
      <item value="&#9; * Create new BeanWrapperImpl, wrapping a new instance of the specified class.&#10;" />
      <item value="Resolved A" />
      <item value="guarantee initialization of beans that the current one depends on" />
      <item value="&#9; * Create a bean instance for the given bean definition.&#10;&#9; * The bean definition will already have been merged with the parent&#10;&#9; * definition in case of a child definition.&#10;&#9; * &lt;p&gt;All the other methods in this class invoke this method, although&#10;&#9; * beans may be cached after being instantiated by this method. All bean&#10;&#9; * instantiation within this class is performed by this method." />
      <item value="&#9; * Get the object for the given shared bean, either the bean&#10;&#9; * instance itself or its created object in case of a FactoryBean." />
      <item value="eagerly check singleton cache for manually registered singletons" />
      <item value="&#9; * Return the bean name, stripping out the factory dereference prefix if necessary,&#10;&#9; * and resolving aliases to canonical names." />
      <item value="Return the set of classes that will get ignored for autowiring." />
      <item value=" * Abstract superclass for BeanFactory implementations.&#10; * Implements the ConfigurableBeanFactory SPI interface.&#10; *&#10; * &lt;p&gt;This class provides singleton/prototype determination, singleton cache,&#10; * aliases, FactoryBean handling, and bean definition merging for child bean&#10; * definitions. It also allows for management of a bean factory hierarchy,&#10; * implementing the HierarchicalBeanFactory interface.&#10; *&#10; * &lt;p&gt;The main template methods to be implemented by subclasses are&#10; * getBeanDefinition and createBean, retrieving a bean definition for&#10; * a given bean name respectively creating a bean instance for a given&#10; * bean definition." />
      <item value="Parent bean factory, for bean inheritance support" />
      <item value="&#9; * Create a new AbstractBeanFactory with the given parent." />
      <item value="&#9; * Parse an element definition: We know this is a BEAN element.&#10;&#9; * Bean elements specify their canonical name as id attribute&#10;&#9; * and their aliases as a delimited name attribute.&#10;&#9; * If no id specified, use the first name in the name attribute as&#10;&#9; * canonical name, registering all others as aliases." />
      <item value=" * Abstract base class for bean definition readers.&#10; * Provides common properties like the bean factory to work on&#10; * and the class loader to use for loading bean classes. " />
      <item value=" * Bean definition reader for Spring's default XML bean definition format.&#10; * Typically applied to a DefaultListableBeanFactory.&#10; *&#10; * &lt;p&gt;The structure, element and attribute names of the required XML document&#10; * are hard-coded in this class. (Of course a transform could be run if necessary&#10; * to produce this format). &quot;beans&quot; doesn't need to be the root element of the XML&#10; * document: This class will parse all bean definition elements in the XML file.&#10; *&#10; * &lt;p&gt;This class registers each bean definition with the given bean factory superclass,&#10; * and relies on the latter's implementation of the BeanDefinitionRegistry interface.&#10; * It supports singletons, prototypes, and references to either of these kinds of bean." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="230" />
        <entry key="ENGLISH" value="231" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>