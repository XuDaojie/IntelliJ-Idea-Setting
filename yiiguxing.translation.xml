<application>
  <component name="AppStorage">
    <histories>
      <item value="Interface to be implemented by beans that need to react once all their&#10; * properties have been set by a BeanFactory: for example, to perform custom&#10; * initialization, or merely to check that all mandatory properties have been set.&#10; * &#10; * &lt;p&gt;An alternative to implementing InitializingBean is specifying a custom&#10; * init-method, for example in an XML bean definition.&#10; * For a list of all bean lifecycle methods, see the BeanFactory javadocs." />
      <item value=" * General purpose factory loading mechanism for internal use within the framework.&#10; *&#10; * &lt;p&gt;{@code SpringFactoriesLoader} {@linkplain #loadFactories loads} and instantiates&#10; * factories of a given type from {@value #FACTORIES_RESOURCE_LOCATION} files which&#10; * may be present in multiple JAR files in the classpath. The {@code spring.factories}&#10; * file must be in {@link Properties} format, where the key is the fully qualified&#10; * name of the interface or abstract class, and the value is a comma-separated list of&#10; * implementation class names. For example:&#10; *&#10; * &lt;pre class=&quot;code&quot;&gt;example.MyService=example.MyServiceImpl1,example.MyServiceImpl2&lt;/pre&gt;&#10; *&#10; * where {@code example.MyService} is the name of the interface, and {@code MyServiceImpl1}&#10; * and {@code MyServiceImpl2} are two implementations." />
      <item value="Properties" />
      <item value="&#9; * Subclasses must return their internal bean factory here.&#10;&#9; * They should implement the lookup efficiently, so that it can be called&#10;&#9; * repeatedly without a performance penalty.&#10;&#9; * @return this application context's internal bean factory" />
      <item value="If the driver is packaged as a Service Provider, load it." />
      <item value="     * Creates a new service loader for the given service type, using the&#10;     * extension class loader.&#10;     *&#10;     * &lt;p&gt; This convenience method simply locates the extension class loader,&#10;     * call it &lt;tt&gt;&lt;i&gt;extClassLoader&lt;/i&gt;&lt;/tt&gt;, and then returns&#10;     *&#10;     * &lt;blockquote&gt;&lt;pre&gt;&#10;     * ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;, &lt;i&gt;extClassLoader&lt;/i&gt;)&lt;/pre&gt;&lt;/blockquote&gt;&#10;     *&#10;     * &lt;p&gt; If the extension class loader cannot be found then the system class&#10;     * loader is used; if there is no system class loader then the bootstrap&#10;     * class loader is used.&#10;     *&#10;     * &lt;p&gt; This method is intended for use when only installed providers are&#10;     * desired.  The resulting service will only find and load providers that&#10;     * have been installed into the current Java virtual machine; providers on&#10;     * the application's class path will be ignored." />
      <item value="Access" />
      <item value="Privileged" />
      <item value="     * Lazily loads the available providers of this loader's service.&#10;     *&#10;     * &lt;p&gt; The iterator returned by this method first yields all of the&#10;     * elements of the provider cache, in instantiation order.  It then lazily&#10;     * loads and instantiates any remaining providers, adding each one to the&#10;     * cache in turn.&#10;     *&#10;     * &lt;p&gt; To achieve laziness the actual work of parsing the available&#10;     * provider-configuration files and instantiating providers must be done by&#10;     * the iterator itself.  Its {@link java.util.Iterator#hasNext hasNext} and&#10;     * {@link java.util.Iterator#next next} methods can therefore throw a&#10;     * {@link ServiceConfigurationError} if a provider-configuration file&#10;     * violates the specified format, or if it names a provider class that&#10;     * cannot be found and instantiated, or if the result of instantiating the&#10;     * class is not assignable to the service type, or if any other kind of&#10;     * exception or error is thrown as the next provider is located and&#10;     * instantiated.  To write robust code it is only necessary to catch {@link&#10;     * ServiceConfigurationError} when using a service iterator.&#10;     *&#10;     * &lt;p&gt; If such an error is thrown then subsequent invocations of the&#10;     * iterator will make a best effort to locate and instantiate the next&#10;     * available provider, but in general such recovery cannot be guaranteed.&#10;     *&#10;     * &lt;blockquote style=&quot;font-size: smaller; line-height: 1.2&quot;&gt;&lt;span&#10;     * style=&quot;padding-right: 1em; font-weight: bold&quot;&gt;Design Note&lt;/span&gt;&#10;     * Throwing an error in these cases may seem extreme.  The rationale for&#10;     * this behavior is that a malformed provider-configuration file, like a&#10;     * malformed class file, indicates a serious problem with the way the Java&#10;     * virtual machine is configured or is being used.  As such it is&#10;     * preferable to throw an error rather than try to recover or, even worse,&#10;     * fail silently.&lt;/blockquote&gt;&#10;     *&#10;     * &lt;p&gt; The iterator returned by this method does not support removal.&#10;     * Invoking its {@link java.util.Iterator#remove() remove} method will&#10;     * cause an {@link UnsupportedOperationException} to be thrown.&#10;     *&#10;     * @implNote When adding providers to the cache, the {@link #iterator&#10;     * Iterator} processes resources in the order that the {@link&#10;     * java.lang.ClassLoader#getResources(java.lang.String)&#10;     * ClassLoader.getResources(String)} method finds the service configuration&#10;     * files.&#10;     *&#10;     * @return  An iterator that lazily loads providers for this loader's&#10;     *          service" />
      <item value="Private inner class implementing fully-lazy provider lookup" />
      <item value="     * Clear this loader's provider cache so that all providers will be&#10;     * reloaded.&#10;     *&#10;     * &lt;p&gt; After invoking this method, subsequent invocations of the {@link&#10;     * #iterator() iterator} method will lazily look up and instantiate&#10;     * providers from scratch, just as is done by a newly-created loader.&#10;     *&#10;     * &lt;p&gt; This method is intended for use in situations in which new providers&#10;     * can be installed into a running Java virtual machine." />
      <item value="The access control context taken when the ServiceLoader is created" />
      <item value="The class loader used to locate, load, and instantiate providers" />
      <item value="         * When callerCl is null, we should check the application's&#10;         * (which is invoking this class indirectly)&#10;         * classloader, so that the JDBC driver class outside rt.jar&#10;         * can be loaded from here.&#10;         */" />
      <item value="     * Removes the specified driver from the {@code DriverManager}'s list of&#10;     * registered drivers.&#10;     * &lt;p&gt;&#10;     * If a {@code null} value is specified for the driver to be removed, then no&#10;     * action is taken.&#10;     * &lt;p&gt;&#10;     * If a security manager exists and its {@code checkPermission} denies&#10;     * permission, then a {@code SecurityException} will be thrown.&#10;     * &lt;p&gt;&#10;     * If the specified driver is not found in the list of registered drivers,&#10;     * then no action is taken.  If the driver was found, it will be removed&#10;     * from the list of registered drivers.&#10;     * &lt;p&gt;&#10;     * If a {@code DriverAction} instance was specified when the JDBC driver was&#10;     * registered, its deregister method will be called&#10;     * prior to the driver being removed from the list of registered drivers.&#10;     *&#10;     * @param driver the JDBC Driver to remove&#10;     * @exception SQLException if a database access error occurs&#10;     * @throws SecurityException if a security manager exists and its&#10;     * {@code checkPermission} method denies permission to deregister a driver.&#10;     *&#10;     * @see SecurityManager#checkPermission" />
      <item value="pure" />
      <item value="deadlock" />
      <item value=" * Interface for accessing attributes at runtime. This is a facade,&#10; * which can accommodate any attributes API such as Jakarta Commons Attributes,&#10; * or (possibly in future) a Spring attributes implementation.&#10; *&#10; * &lt;p&gt;The purpose of using this interface is to decouple Spring code from any&#10; * specific attributes implementation. Even once JSR-175 is available, there&#10; * is still value in such a facade interface, as it allows for hierarchical&#10; * attribute sources: for example, an XML file or properties file might override&#10; * some attributes defined in source-level metadata with JSR-175 or another framework." />
      <item value=" * A simple wrapper for exceptions that occur within the metadata package.&#10;" />
      <item value="reworked" />
      <item value="introduced" />
      <item value="unsatisfied" />
      <item value="&#9; * Return an array of object-type property names that are unsatisfied.&#10;&#9; * These are probably unsatisfied references to other beans in the&#10;&#9; * factory. Does not include simple properties like primitives or Strings." />
      <item value="&#9; * Fills in any missing property values with references to&#10;&#9; * other beans in this factory if autowire is set to &quot;byName&quot;." />
      <item value="Property Values" />
      <item value="Mutable" />
      <item value="&#9; * &quot;autowire constructor&quot; (with constructor arguments by type) behaviour.&#10;&#9; * Also applied if explicit constructor argument values are specified,&#10;&#9; * matching all remaining arguments with beans from the bean factory.&#10;&#9; * &lt;p&gt;This corresponds to constructor injection: In this mode, a Spring&#10;&#9; * bean factory is able to host components that expect constructor-based&#10;&#9; * dependency resolution." />
      <item value="Event raised when an ApplicationContext gets initialized or refreshed." />
      <item value=" * Interface to be implemented by event listeners.&#10; * Based on standard java.util base class for Observer" />
      <item value="&#9;&#9;// last step: publish respective event&#10;" />
      <item value="&#9;&#9;// instantiate singletons this late to allow them to access the message source&#10;" />
      <item value="&#9; * Add beans that implement ApplicationListener as listeners.&#10;&#9; * Doesn't affect other listeners, which can be added without being beans." />
      <item value=" * Utilities common to all UI application context implementations.&#10;" />
      <item value="Initialize the theme capability." />
      <item value="&#9; * Template method which can be overridden to add context-specific refresh work.&#10;&#9; * Called on initialization of special beans, before instantiation of singletons.&#10;&#9; * @throws BeansException in case of errors during refresh" />
      <item value="initialize other special beans in specific context subclasses" />
      <item value="&#9; * Instantiate and invoke all registered BeanPostProcessor beans,&#10;&#9; * respecting explicit order if given.&#10;&#9; * Must be called before singleton instantiation." />
      <item value="&#9; * Modify the application context's internal bean factory after its standard&#10;&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for overriding or adding&#10;&#9; * properties even to eager-initializing beans.&#10;&#9; * @param beanFactory the bean factory used by the application context" />
      <item value="&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for overriding or adding&#10;&#9; * properties even to eager-initializing beans.&#10;&#9; * @param beanFactory the bean factory used by the application context&#10;&#9; * @throws org.springframework.beans.BeansException in case of errors" />
      <item value="invoke factory processors registered with the context instance" />
      <item value="&#9; * Modify the application context's internal bean factory after its standard&#10;&#9; * initialization. All bean definitions will have been loaded, but no beans&#10;&#9; * will have been instantiated yet. This allows for registering special&#10;&#9; * BeanPostProcessors etc in certain ApplicationContext implementations.&#10;&#9; * @param beanFactory the bean factory used by the application context&#10;&#9; * @throws org.springframework.beans.BeansException in case of errors" />
      <item value="&#9; * Set the ResourceLoader that this object runs in.&#10;&#9; * &lt;p&gt;Invoked after population of normal bean properties but before an init&#10;&#9; * callback like InitializingBean's afterPropertiesSet or a custom init-method.&#10;&#9; * Invoked before ApplicationContextAware's setApplicationContext.&#10;&#9; * @param resourceLoader ResourceLoader object to be used by this object" />
      <item value="Aware" />
      <item value="&#9; * Subclasses must implement this method to perform the actual configuration load.&#10;&#9; * The method is invoked by refresh before any other initialization work.&#10;&#9; * @see #refresh" />
      <item value="&#9;&#9;// tell subclass to refresh the internal bean factory&#10;" />
      <item value="&#9; * Load or reload configuration.&#10;&#9; * @throws org.springframework.context.ApplicationContextException if the configuration&#10;&#9; * was invalid or couldn't be found, or if configuration has already been loaded and&#10;&#9; * reloading is forbidden&#10;&#9; * @throws BeansException if the bean factory could not be initialized" />
      <item value=" * &lt;p&gt;See PropertyResourceConfigurer and its concrete implementations&#10; * for out-of-the-box solutions that address such configuration needs." />
      <item value=" * &lt;p&gt;Useful for custom config files targeted at system administrators that&#10; * override bean properties configured in the application context." />
      <item value=" * Partial implementation of ApplicationContext. Doesn't mandate the type&#10; * of storage used for configuration, but implements common functionality.&#10; * Uses the Template Method design pattern, requiring concrete subclasses&#10; * to implement abstract methods.&#10; *&#10; * &lt;p&gt;In contrast to a plain bean factory, an ApplicationContext is supposed&#10; * to detect special beans defined in its bean factory: Therefore, this class&#10; * automatically registers BeanFactoryPostProcessors, BeanPostProcessors&#10; * and ApplicationListeners that are defined as beans in the context.&#10; *&#10; * &lt;p&gt;A MessageSource may be also supplied as a bean in the context, with&#10; * the name &quot;messageSource&quot;. Else, message resolution is delegated to the&#10; * parent context.&#10; *&#10; * &lt;p&gt;Implements resource loading through extending DefaultResourceLoader.&#10; * Therefore, treats resource paths as class path resources. Only supports&#10; * full classpath resource names that include the package path, like&#10; * &quot;mypackage/myresource.dat&quot;." />
      <item value="&#9; * Return a friendly name for this context.&#10;&#9; * @return a display name for this context" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="283" />
        <entry key="ENGLISH" value="284" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="FRENCH" value="1" />
        <entry key="SPANISH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="translateDocumentation" value="false" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>