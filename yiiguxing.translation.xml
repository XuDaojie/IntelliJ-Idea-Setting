<application>
  <component name="AppStorage">
    <histories>
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;" />
      <item value="&#9; * Return a RootBeanDefinition, even by traversing parent if the parameter is a child definition.&#10;&#9; * Will ask the parent bean factory if not found in this instance." />
      <item value="check if bean definition exists" />
      <item value="&#9;&#9;// Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Eagerly cache singletons to be able to resolve circular references&#10;&#9;&#9;// even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Register the given custom property editor for all properties of the&#10;&#9; * given type." />
      <item value="&#9; * Initialize the given BeanWrapper with the custom editors registered&#10;&#9; * with this factory." />
      <item value=" * Default implementation of the BeanWrapper interface that should be sufficient&#10; * for all normal uses. Caches introspection results for efficiency.&#10; *&#10; * &lt;p&gt;Note: This class never tries to load a class by name, as this can pose&#10; * class loading problems in J2EE applications with multiple deployment modules.&#10; * The caller is responsible for loading a target class.&#10; *&#10; * &lt;p&gt;Note: Auto-registers all default property editors (not the custom ones)&#10; * in the org.springframework.beans.propertyeditors package.&#10; * Applications can either use a standard PropertyEditorManager to register a&#10; * custom editor before using a BeanWrapperImpl instance, or call the instance's&#10; * registerCustomEditor method to register an editor for the particular instance.&#10; *&#10; * &lt;p&gt;BeanWrapperImpl will convert List and array values to the corresponding&#10; * target arrays, if necessary. Custom property editors that deal with Lists or&#10; * arrays can be written against a comma delimited String as String arrays are&#10; * converted in such a format if the array itself is not assignable." />
      <item value="&#9; * Create new BeanWrapperImpl, wrapping a new instance of the specified class.&#10;" />
      <item value="Resolved A" />
      <item value="guarantee initialization of beans that the current one depends on" />
      <item value="&#9; * Create a bean instance for the given bean definition.&#10;&#9; * The bean definition will already have been merged with the parent&#10;&#9; * definition in case of a child definition.&#10;&#9; * &lt;p&gt;All the other methods in this class invoke this method, although&#10;&#9; * beans may be cached after being instantiated by this method. All bean&#10;&#9; * instantiation within this class is performed by this method." />
      <item value="&#9; * Get the object for the given shared bean, either the bean&#10;&#9; * instance itself or its created object in case of a FactoryBean." />
      <item value="eagerly check singleton cache for manually registered singletons" />
      <item value="&#9; * Return the bean name, stripping out the factory dereference prefix if necessary,&#10;&#9; * and resolving aliases to canonical names." />
      <item value="Return the set of classes that will get ignored for autowiring." />
      <item value=" * Abstract superclass for BeanFactory implementations.&#10; * Implements the ConfigurableBeanFactory SPI interface.&#10; *&#10; * &lt;p&gt;This class provides singleton/prototype determination, singleton cache,&#10; * aliases, FactoryBean handling, and bean definition merging for child bean&#10; * definitions. It also allows for management of a bean factory hierarchy,&#10; * implementing the HierarchicalBeanFactory interface.&#10; *&#10; * &lt;p&gt;The main template methods to be implemented by subclasses are&#10; * getBeanDefinition and createBean, retrieving a bean definition for&#10; * a given bean name respectively creating a bean instance for a given&#10; * bean definition." />
      <item value="Parent bean factory, for bean inheritance support" />
      <item value="&#9; * Create a new AbstractBeanFactory with the given parent." />
      <item value="&#9; * Parse an element definition: We know this is a BEAN element.&#10;&#9; * Bean elements specify their canonical name as id attribute&#10;&#9; * and their aliases as a delimited name attribute.&#10;&#9; * If no id specified, use the first name in the name attribute as&#10;&#9; * canonical name, registering all others as aliases." />
      <item value=" * Abstract base class for bean definition readers.&#10; * Provides common properties like the bean factory to work on&#10; * and the class loader to use for loading bean classes. " />
      <item value=" * Bean definition reader for Spring's default XML bean definition format.&#10; * Typically applied to a DefaultListableBeanFactory.&#10; *&#10; * &lt;p&gt;The structure, element and attribute names of the required XML document&#10; * are hard-coded in this class. (Of course a transform could be run if necessary&#10; * to produce this format). &quot;beans&quot; doesn't need to be the root element of the XML&#10; * document: This class will parse all bean definition elements in the XML file.&#10; *&#10; * &lt;p&gt;This class registers each bean definition with the given bean factory superclass,&#10; * and relies on the latter's implementation of the BeanDefinitionRegistry interface.&#10; * It supports singletons, prototypes, and references to either of these kinds of bean." />
      <item value="&#9; * Register the bean definitions contained in the given DOM document.&#10;&#9; * All calls go through this." />
      <item value="&#9; * Load bean definitions from the specified XML file.&#10;" />
      <item value="&#9; * Set a SAX entity resolver to be used for parsing. By default, BeansDtdResolver&#10;&#9; * will be used. Can be overridden for custom entity resolution, e.g. relative&#10;&#9; * to some specific base path." />
      <item value="Resolver" />
      <item value=" * Default implementation of the XmlBeanDefinitionParser interface.&#10; * Parses bean definitions according to the &quot;spring-beans&quot; DTD. " />
      <item value="&#9; * Register the bean definitions contained in the given DOM document.&#10;&#9; * All calls go through this.&#10;&#9; * @param doc the DOM document&#10;&#9; * @throws BeansException in case of parsing errors" />
      <item value=" * Strategy interface for parsing XML bean definitions.&#10; * Used by XmlBeanDefinitionReader for actually parsing a DOM document.&#10; *&#10; * &lt;p&gt;Instantiated per document to parse: Implementations can hold state in&#10; * instance variables during the execution of the registerBeanDefinitions&#10; * method, for example global settings that are defined for all bean&#10; * definitions in the document." />
      <item value="&#9; * Parse bean definitions from the given DOM document,&#10;&#9; * and register them with the given bean factory.&#10;&#9; * @param beanFactory the bean factory to register the bean definitions with&#10;&#9; * @param beanClassLoader class loader to use for bean classes&#10;&#9; * (null suggests to not load bean classes but just register bean definitions&#10;&#9; * with class names, for example when just registering beans in a registry&#10;&#9; * but not actually instantiating them in a factory)&#10;&#9; * @param doc the DOM document&#10;&#9; * @param resource descriptor of the original XML resource&#10;&#9; * (useful for displaying parse errors)&#10;&#9; * @throws BeansException in case of parsing errors" />
      <item value=" * Abstract BeanFactory superclass that implements default bean creation.&#10; * Implements the AutowireCapableBeanFactory interface.&#10; *&#10; * &lt;p&gt;Provides bean creation, initialization and wiring, supporting&#10; * autowiring and constructor resolution. Handles runtime bean references,&#10; * managed collections, and bean destruction.&#10; *&#10; * &lt;p&gt;The main template method to be implemented by subclasses is&#10; * findMatchingBeans, used for autowiring by type. Note that this class&#10; * does &lt;i&gt;not&lt;/i&gt; implement bean definition registry capabilities&#10; * (DefaultListableBeanFactory does)." />
      <item value="definitions" />
      <item value="1. Those steps don't work currently for Intellij IDEA 13+&#10;2. `spring-aspects` does not compile out of the box due to references to aspect types unknown to IDEA.&#10;See http://youtrack.jetbrains.com/issue/IDEA-64446 for details. In the meantime, the 'spring-aspects'&#10;module has been excluded from the overall project to avoid compilation errors.&#10;3. While all JUnit tests pass from the command line with Gradle, many will fail when run from IDEA.&#10;Resolving this is a work in progress. If attempting to run all JUnit tests from within IDEA, you will&#10;likely need to set the following VM options to avoid out of memory errors:&#10;    -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m" />
      <item value=" Those steps don't work currently for Intellij IDEA 13+" />
      <item value="Waits for this future to be completed without interruption. This method catches an InterruptedException and discards it silently. " />
      <item value="Waits for this future to be completed without interruption. This method catches an InterruptedException and discards it silently.&#10;" />
      <item value="await Uninterruptibly" />
      <item value="     * Waits for this future to be completed without&#10;     * interruption.  This method catches an {@link InterruptedException} and&#10;     * discards it silently." />
      <item value="Expirable" />
      <item value="Acquires the lock with defined leaseTime. Waits if necessary until lock became available. Lock will be released automatically after defined leaseTime interval" />
      <item value=" java.util.concurrent.locks.Lock Acquires the lock only if it is free at the time of invocation. Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false. A typical usage idiom for this method would be:     Lock lock = ...;  if (lock.tryLock()) {    try {      // manipulate protected state    } finally {      lock.unlock();    }  } else {    // perform alternative actions  } This usage ensures that the lock is unlocked if it was acquired, and doesn't try to unlock if the lock was not acquired." />
      <item value="&#10;java.util.concurrent.locks.Lock Acquires the lock only if it is free at the time of invocation.&#10;Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false.&#10;A typical usage idiom for this method would be:&#10;  &#10; Lock lock = ...;&#10; if (lock.tryLock()) {&#10;   try {&#10;     // manipulate protected state&#10;   } finally {&#10;     lock.unlock();&#10;   }&#10; } else {&#10;   // perform alternative actions&#10; }&#10;This usage ensures that the lock is unlocked if it was acquired, and doesn't try to unlock if the lock was not acquired." />
      <item value="Acquires the lock. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired. Implementation Considerations A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation." />
      <item value="Acquires the lock.&#10;If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.&#10;Implementation Considerations&#10;A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation." />
      <item value="Acquires the lock only if it is free at the time of invocation. Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false. A typical usage idiom for this method would be:" />
      <item value="Acquires the lock only if it is free at the time of invocation.&#10;Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false.&#10;A typical usage idiom for this method would be:" />
      <item value="     * Waits for this future until it is done, and rethrows the cause of the failure if this future&#10;     * failed.&#10;     * &#10;     * @return Future object" />
      <item value="Waits for this future until it is done, and rethrows the cause of the failure if this future&#10;     * failed." />
      <item value=" * RedLock locking algorithm implementation for multiple locks. &#10; * It manages all locks as one." />
      <item value="remain" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="202" />
        <entry key="ENGLISH" value="203" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
        <entry key="SPANISH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="33b178d8a0960b4a" />
      </youdao-translate>
    </option>
  </component>
</application>